<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="专注于编程技术和数据科学、人工智能">
  <meta name="keyword" content="人工智能, 数据科学, Python, 编程, 程序员, 开发者, web, 网站, 语言, 程序, UI, 美工, 设计师">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      通过内置对象理解 Python（四） | 老齐教室
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>老齐教室</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">书籍</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/courses/" class="item-link">课程</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">类目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/resources/" class="item-link">资源</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">书籍</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/courses/" class="menu-link">课程</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">类目</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/resources/" class="menu-link">资源</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            

          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  
  <!-- <div class="arrow-down">
    <a href="javascript:;"></a>
  </div> -->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <h2>通过内置对象理解 Python（四）</h2>
    <p class="post-date">2021-11-03</p>
    <section class="markdown-content"><h3 id="str-bytes-int-bool-float-and-complex：五个基本类型"><a href="#str-bytes-int-bool-float-and-complex：五个基本类型" class="headerlink" title="str, bytes, int, bool, float and complex：五个基本类型"></a><code>str</code>, <code>bytes</code>, <code>int</code>, <code>bool</code>, <code>float</code> and <code>complex</code>：五个基本类型</h3><p>Python有6个基本的数据类型（分明是5个，随后会解释）。 其中4个是数字，另外2个基于文本。</p>
<p>先看基于文本的数据类型，因为简单。  </p>
<p><code>str</code> 是 Python 中最常见的数据类型之一，使用 <code>input</code> 函数接受用户输入会得到字符串，Python 中的其他所有数据类型都可以转换成字符串。 这是必要的，因为所有计算机输入/输出都是文本形式的，无论是用户 I/O 还是文件 I/O ，这可能是字符串无处不在的原因。  </p>
<p><code>bytes</code> 字节类型实际上是计算中所有 I/O 的基础。 如果你了解计算机，可能会知道所有的数据都是以位和字节的形式存储和处理的——这也是终端真正的工作方式。  </p>
<p> 如果想看一下位于 <code>input</code> 和 <code>print</code> 之下的字节，需要查看 <code>sys</code> 模块中的 I/O 缓存： <code>sys.stdout.buffer</code> 和 <code>sys.stdin.buffer</code> ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Hello!'</span>)</span><br><span class="line">Hello!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello!\n'</span>.encode()  <span class="comment"># Produces bytes</span></span><br><span class="line"><span class="string">b'Hello!\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>char_count = sys.stdout.buffer.write(<span class="string">'Hello!\n'</span>.encode())</span><br><span class="line">Hello!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>char_count  <span class="comment"># write() returns the number of bytes written to console</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>buffer 对象接收字节，把它们直接写入输出缓存，并返回字节数。  </p>
<p>为了证明下面的一切都是字节，让我们看看另一个使用字节打印表情的例子:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'🐍'</span>.encode()</span><br><span class="line"><span class="string">b'\xf0\x9f\x90\x8d'</span>   <span class="comment"># utf-8 encoded string of the snake emoji</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_ = sys.stdout.buffer.write(<span class="string">b'\xf0\x9f\x90\x8d'</span>)</span><br><span class="line">🐍</span><br></pre></td></tr></table></figure>

<p><code>int</code> 是另一种广泛使用的基本数据类型。 它也是另外两种数据类型 <code>float</code> 和 <code>complex</code> 的最小单元， <code>complex</code> 是 <code>float</code> 的超类，而 <code>float</code> 又是 <code>int</code> 的超类。  </p>
<p>这意味着所有的 <code>int</code> 也可以视作 <code>float</code> 或 <code>complex</code> ，但反过来说就不成立了。 类似地，所有的 <code>float</code> 可以作为 <code>complex</code> 。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = <span class="number">5.0</span>+<span class="number">0.0j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(x), type(y), type(z)</span><br><span class="line">(&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'complex'&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == y == z  <span class="comment"># All the same value</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(x)    <span class="comment"># float(x) produces the same result as y</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">(<span class="number">5</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(x)  <span class="comment"># complex(x) produces the same result as z</span></span><br><span class="line">(<span class="number">5</span>+<span class="number">0j</span>)</span><br></pre></td></tr></table></figure>

<p>刚才提到 Python 中实际上只有5个基本数据类型，而不是6个。 这是因为，<code>bool</code> 实际上不是一个基本数据类型——它实际上是 <code>int</code> 的子类!  </p>
<p>你可以通过查看这些类的 <code>mro</code> 属性来查验上述说法。  </p>
<p><code>mro</code> 意思是“方法解析顺序”，它定义了在类中所有方法的搜索顺序。 调用某个方法，首先在类本身中查找，如果找不到，则会在父类中搜索，然后是再上一级的父类，一直到顶端的 <code>object</code> 类。 Python中的一切都继承自 <code>object</code> 。 是的，Python中几乎所有东西都是对象。 </p>
<p>看一看下面的代码:  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int.mro()</span><br><span class="line">[&lt;class 'int'&gt;, &lt;class 'object'&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float.mro()</span><br><span class="line">[&lt;class 'float'&gt;, &lt;class 'object'&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex.mro()</span><br><span class="line">[&lt;class 'complex'&gt;, &lt;class 'object'&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.mro()</span><br><span class="line">[&lt;class 'str'&gt;, &lt;class 'object'&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool.mro()</span><br><span class="line">[&lt;class 'bool'&gt;, &lt;class 'int'&gt;, &lt;class 'object'&gt;]  # Look!</span><br></pre></td></tr></table></figure>

<p>所有类都有共同的“祖先” <code>object</code> 。 <code>bool</code>是居然继承了 <code>int</code> 类。 </p>
<p>或许对 <code>bool</code> 是 <code>int</code> 的子类感觉奇怪。这主要是历史原因造成的。在历史上，曾经用 <code>0</code> 和 <code>1</code> 分别表示逻辑假和真，后来，在 Python 2.2 才引入了 <code>True</code> 和 <code>False</code> 这两个 <code>bool</code> 类型的值，为了能兼容，把它们设计成整数的包装器。于是这个事实就被延续至今。</p>
<p>基于这个事实，就能在本需要整数地方，用 <code>bool</code> 类型替代了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: &#123;<span class="string">'c'</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data))</span><br><span class="line">&#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: &#123;<span class="string">"c"</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"a"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"b"</span>: &#123;</span><br><span class="line">        <span class="string">"c"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="literal">True</span>))</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"a"</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">"b"</span>: &#123;</span><br><span class="line">  <span class="string">"c"</span>: <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>indent=True</code> 被视为 <code>indent=1</code> ，所以它是有效的，但我确信没有人会想要缩进1个空格。  </p>
<h3 id="object-：基类"><a href="#object-：基类" class="headerlink" title="object ：基类"></a><code>object</code> ：基类</h3><p><code>object</code> 是整个类层次结构的基类，每个类都继承了 <code>object</code> 。 </p>
<p><code>object</code> 类中通过特殊方法，定义了 Python 中的一些最基本的函数，比如，通过 <code>__hash__()</code> 可以定义函数 <code>hash()</code> ，等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(object)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>,</span><br><span class="line"><span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>,</span><br><span class="line"><span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>,</span><br><span class="line"><span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure>

<p>使用 <code>obj.x</code> 形式访问属性会调用 <code>__getattr__()</code> 方法。 类似地，设置新属性和删除属性分别调用 <code>__setattr__()</code> 和 <code>__delattr__()</code> 。 对象的哈希值由 <code>__hash__()</code> 方法生成，对象的字符串表示形式来自 <code>__repr__()</code>。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>object()  <span class="comment"># This creates an object with no properties</span></span><br><span class="line">&lt;object object at <span class="number">0x7f47aecaf210</span>&gt;  <span class="comment"># defined in __repr__()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">dummy</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = dummy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;__main__.dummy object at <span class="number">0x7f47aec510a0</span>&gt;  <span class="comment"># functionality inherited from object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(object())</span><br><span class="line"><span class="number">8746615746334</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(x)</span><br><span class="line"><span class="number">8746615722250</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__hash__()  <span class="comment"># is the same as hash(x)</span></span><br><span class="line"><span class="number">8746615722250</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，关于 Python 的特殊方法还有很多内容，推荐参考《Python大学实用教程》或《Python 完全自学教程》，参阅：<a href="http://www.itdifferc.om" target="_blank" rel="noopener">www.itdifferc.om</a> 的说明。</p>
</blockquote>
<h3 id="type-：类工厂"><a href="#type-：类工厂" class="headerlink" title="type ：类工厂"></a><code>type</code> ：类工厂</h3><p>如果 <code>object</code> 是所有对象之父，那么 <code>type</code> 就是所有“类”之父。即所有的对象继承 <code>object</code> ，所有的类来自于 <code>type</code> 。  </p>
<p><code>type</code> 可以用来动态地创建新类，它有两种用途:  </p>
<ul>
<li><p>如果给定一个参数，它返回该参数的“类型”，即：用于创建该对象的类:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(x)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(x)</span> <span class="title">is</span> <span class="title">int</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(x)</span><span class="params">(<span class="number">42.0</span>)</span>  # <span class="title">Same</span> <span class="title">as</span> <span class="title">int</span><span class="params">(<span class="number">42.0</span>)</span></span></span><br><span class="line"><span class="class">42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用三个参数，可以创建一个新类，这三个参数是 <code>name</code> 、<code>bases</code> 和 <code>dict</code> 。</p>
<ul>
<li><p><code>name</code> 定义类的名称  </p>
</li>
<li><p><code>bases</code> 定义所继承的类  </p>
</li>
<li><p><code>dict</code> 定义了所有的类属性和方法。  </p>
</li>
</ul>
<p>如果要定义这样的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MySuperClass)</span>:</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span>       </span><br><span class="line">        print(<span class="string">'x'</span>)</span><br></pre></td></tr></table></figure>

<p>用 <code>type</code> 可以定义同样的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x_function</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'x'</span>)</span><br><span class="line"></span><br><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (MySuperClass), &#123;<span class="string">'x'</span>: x_function&#125;)</span><br></pre></td></tr></table></figure>

<p>这也是实现 <code>collections.namedtuple</code> 类的一种方法，例如，它以类的名字和元组作为参数。</p>
</li>
</ul>
<h3 id="hash-and-id-：判断相等的基础"><a href="#hash-and-id-：判断相等的基础" class="headerlink" title="hash and id ：判断相等的基础"></a><code>hash</code> and <code>id</code> ：判断相等的基础</h3><p>Python的内置函数 <code>hash</code> 和 <code>id</code> 是用于判断对象相等的依据。  </p>
<p> Python 对象默认情况下是不具有可比性的，除非它们是完全相同的。 如果你尝试创建两个 <code>object()</code> 对象并检查它们是否相等…  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == x</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y == y</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == y  <span class="comment"># Comparing two objectsFalse</span></span><br></pre></td></tr></table></figure>

<p>结果总是 <code>False</code> 。 这是因为：事实上，<code>object</code> 以同一性来比较自己，即它们只是与自己相等，而不是与别的对象相等。  </p>
<hr>
<p><strong>补充知识：</strong>哨兵</p>
<p>For this reason, <code>object</code> instances are also sometimes  called a “sentinel”, because they can be used to check for a value  exactly, that can’t be replicated.</p>
<p>通常很少用类 <code>object</code> 直接创建实例，在编程中，有一种情景可以使用 <code>object</code>实例，并且称此实例为“哨兵”，这是什么意思呢？</p>
<p>看下面的例子。假设有一个函数 <code>what_was_passed</code> ，用它能够实现下面所演示的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(<span class="number">42</span>)</span><br><span class="line">You passed a <span class="number">42.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(<span class="string">'abc'</span>)</span><br><span class="line">You passed a <span class="string">'abc'</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed()</span><br><span class="line">Nothing was passed.</span><br></pre></td></tr></table></figure>

<p>也就是，只要输入一个非空的值，就能对应相应的输出；如果输入的是控制，则提示 <code>Nothing was passed</code> 。或许觉得这个函数的代码很容易编写，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">what_was_passed</span><span class="params">(value=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">'Nothing was passed.'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">f'You passed a <span class="subst">&#123;value!r&#125;</span>.'</span>)</span><br></pre></td></tr></table></figure>

<p>但是，如果提供的参数就是 <code>None</code> ——注意，<code>None</code> 在有的情况下，并不表示“什么也没有”，也可能具有某种意义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(<span class="literal">None</span>)</span><br><span class="line">Nothing was passed.</span><br></pre></td></tr></table></figure>

<p>显然这样做，并不总能实现期望。或者以省略号 <code>...</code> 为参数（详见<a href="https://mp.weixin.qq.com/s/tdXq4f5RBT8GNn7RF4gBmg" target="_blank" rel="noopener">《Python 中的省略号》</a>），也不能通过测试。</p>
<p>这时就需要一个“哨兵”了：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__my_sentinel = object()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">what_was_passed</span><span class="params">(value=__my_sentinel)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> __my_sentinel:</span><br><span class="line">        print(<span class="string">'Nothing was passed.'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">f'You passed a <span class="subst">&#123;value!r&#125;</span>.'</span>)</span><br></pre></td></tr></table></figure>

<p>现在，不论给函数提供任何职，都能看做对象，只有在不提供值时才为空。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(<span class="number">42</span>)</span><br><span class="line">You passed a <span class="number">42.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(<span class="string">'abc'</span>)</span><br><span class="line">You passed a <span class="string">'abc'</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(<span class="literal">None</span>)</span><br><span class="line">You passed a <span class="literal">None</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed(object())</span><br><span class="line">You passed a &lt;object object at <span class="number">0x7fdf02f3f220</span>&gt;.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what_was_passed()</span><br><span class="line">Nothing was passed.</span><br></pre></td></tr></table></figure>

<p>（补充知识完毕）</p>
<hr>
<p>要理解为什么对象只与自己比较，我们必须理解关键词 <code>is</code> 。  </p>
<p>Python 的 <code>is</code> 用于检查两个名称是否在内存中引用了完全相同的对象。 我们可以把 Python 对象想象成在空间中漂浮的盒子，把变量、数组索引等想象成指向这些对象的箭头。  </p>
<p>举个简单的例子:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> y</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y <span class="keyword">is</span> z</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，有两个独立的对象，三个标签 <code>x</code> ，<code>y</code> 和 <code>z</code> 指向这两个对象：<code>x</code> 指向第一个对象，<code>y</code> 和 <code>z</code> 都指向另一个对象。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x</span><br></pre></td></tr></table></figure>

<p>这个操作将删除箭头 <code>x</code> 。 对象本身不受赋值或删除的影响，只有箭头受影响。 但现在没有指向第一个对象的箭头，这个对象的存在也就没有意义了。 所以 Python 的“垃圾回收器”将其清除。 现在我们只剩下一个 <code>object</code> 了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>现在 <code>y</code> 箭头被改为指向一个整数对象 <code>5</code> 。 <code>z</code> 仍然指向第二个 <code>object</code> ，所以该对象仍然存在。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = y * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>现在 <code>z</code> 指向另一个新对象 <code>10</code> ，这个新对象存储在内存中的某个地方。 现在也没有箭头指向第二个<code>object</code>了，因此该对象随后被作为垃圾收走。 </p>
<p>为了能够验证所有上述说法，我们可以使用 <code>id</code> 内置函数。 <code>id</code> 表示对象在内存中的确切位置，用数字表示。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(x)</span><br><span class="line"><span class="number">139737240793600</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(y)</span><br><span class="line"><span class="number">139737240793616</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(z)</span><br><span class="line"><span class="number">139737240793616</span>  <span class="comment"># Notice the numbers!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> y</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(x) == id(y)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y <span class="keyword">is</span> z</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(y) == id(z)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>相同的对象，相同的 <code>id()</code> 返回值，否则不同。</p>
<p>With <code>object</code>s, <code>==</code> and <code>is</code> behaves the same way:</p>
<p>对于 <code>object</code> 类的示例对象，<code>==</code> 和 <code>is</code> 具有相同的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> y</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == y</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y <span class="keyword">is</span> z</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y == z</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这是因为，在 <code>object</code> 类中，专门定义了针对 <code>==</code> 的方法 <code>__eq__</code> ，像下面这样:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="keyword">is</span> other</span><br></pre></td></tr></table></figure>

<p>当然，实际上 <code>object</code> 的实现是用 C 语言编写的。</p>
<p>另一方面，如果容器类型可以相互替换，则它们是相等的。典型例子是具有相同索引的相同项的列表，或者包含完全相同值的集合。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> y</span><br><span class="line"><span class="literal">False</span>       <span class="comment"># Different objects,</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == y</span><br><span class="line"><span class="literal">True</span>        <span class="comment"># Yet, equal.</span></span><br></pre></td></tr></table></figure>

<p>这些可以这样定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> all(x == y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(self, other))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Can also be written as:</span></span><br><span class="line">        <span class="keyword">return</span> all(self[i] == other[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self)))</span><br></pre></td></tr></table></figure>

<p>类似地，集合是无序的，所以成员的位置无关紧要，重要的是它们的“存在”:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) != len(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> all(item <span class="keyword">in</span> other <span class="keyword">for</span> item <span class="keyword">in</span> self)</span><br></pre></td></tr></table></figure>

<p>现在，开始讨论“等价”的概念。Python 有<strong>哈希</strong>（或：散列）的概念。 任何数据块的“散列”指的都是一个看起来非常随机的预计算值，但它在某种程度上可以用于标识该数据块。  </p>
<p>哈希有两个特定的属性:  </p>
<ul>
<li><p>相同的数据块总是有相同的哈希值。  </p>
</li>
<li><p>即使只是稍微改变数据，也会返回一个完全不同的哈希值。  </p>
</li>
</ul>
<p>这意味着，如果两个数据块具有相同的哈希值，那么它们也很可能具有相同的值。</p>
<p>比较哈希值是检查“是否存在”的一种非常快速的方法。 这就是字典和集合用来快速查找内部的值的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'999 in l'</span>, setup=<span class="string">'l = list(range(1000))'</span>)</span><br><span class="line"><span class="number">12.224023487000522</span>   <span class="comment"># 12 seconds to run a million times</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'999 in s'</span>, setup=<span class="string">'s = set(range(1000))'</span>)</span><br><span class="line"><span class="number">0.06099735599855194</span>  <span class="comment"># 0.06 seconds for the same thing</span></span><br></pre></td></tr></table></figure>

<p>注意：集合解决方案的运行速度比列表解决方案快数百倍!！这是因为它们使用哈希值作为“索引”的替代，如果相同哈希<em>的值</em>已经存储在集合或字典中，Python 可以快速检查它是否是同一项。 这个过程可以非常即时地检查哈希值是否存在。</p>
<hr>
<p><strong>补充知识：</strong>关于哈希</p>
<p>在 Python中，所有相等的数值都具有相同的哈希值，这一点往往鲜为人知。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="number">42</span>) == hash(<span class="number">42.0</span>) == hash(<span class="number">42</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另一个事实是不可变对象，如字符串、元组和不可变集合，通过组合各项的哈希来生成它们自己的哈希。 这使得你只需通过编写 <code>hash</code> 函数就可以为类创建自定义哈希函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color, wheels=<span class="number">4</span>)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line">        self.wheels = wheels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash((self.color, self.wheels))</span><br></pre></td></tr></table></figure>

<p>（补充知识结束）</p>
<hr>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/11/03/python-builtins-third/">
        <span class="nav-arrow">← </span>
        
          通过内置对象理解 Python（三）
        
      </a>
    
    
      <a class="nav-right" href="/2021/11/03/python-builtins-fifth/">
        
          通过内置对象理解 Python（五）
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <!--% if (theme.qrcode) { %-->
      <div class="qrcode">
        <!--canvas id="share-qrcode"></!--canvas-->
        <img src="https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg" width=400>
        <p class="notice">关注微信公众号，读文章、听课程，提升技能</p>
      </div>
    <!--% } %-->
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#str-bytes-int-bool-float-and-complex：五个基本类型"><span class="toc-nav-text">str, bytes, int, bool, float and complex：五个基本类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#object-：基类"><span class="toc-nav-text">object ：基类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#type-：类工厂"><span class="toc-nav-text">type ：类工厂</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#hash-and-id-：判断相等的基础"><span class="toc-nav-text">hash and id ：判断相等的基础</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://qiwsir.github.io/2021/11/03/python-builtins-forth/';
    var banner = ''
    /*if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }*/
    //$('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by 老齐教室 | <a href='http://www.beian.miit.gov.cn' target="_blank" rel="noopener">苏ICP备13034293号-2 </a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>