<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="专注于编程技术和数据科学、人工智能">
  <meta name="keyword" content="人工智能, 数据科学, Python, 编程, 程序员, 开发者, web, 网站, 语言, 程序, UI, 美工, 设计师">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Python 中的递归 | 老齐教室
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>老齐教室</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">书籍</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/courses/" class="item-link">课程</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">类目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/resources/" class="item-link">资源</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">书籍</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/courses/" class="menu-link">课程</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">类目</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/resources/" class="menu-link">资源</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            

          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  
  <!-- <div class="arrow-down">
    <a href="javascript:;"></a>
  </div> -->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <h2>Python 中的递归</h2>
    <p class="post-date">2021-06-03</p>
    <section class="markdown-content"><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>递归（recursion）这个单词来自拉丁语中的 <em>recurre</em>，意思是：匆匆而归、返回、还原或重现。以下是网络上对递归的一些定义：</p>
<ul>
<li><p><a href="https://www.dictionary.com/browse/recursion" target="_blank" rel="noopener">Dictionary.com</a>：表示返回的行为或过程。</p>
</li>
<li><p><a href="https://en.wiktionary.org/wiki/recursion" target="_blank" rel="noopener">Wiktionary</a> ：在对象内部定义使用该对象（通常是函数）的操作。</p>
</li>
<li><p><a href="https://www.thefreedictionary.com/recursion" target="_blank" rel="noopener">The Free Dictionary</a>：定义一系列对象的方法，如表达式、函数、集合等，给定一些初始对象，并且根据根据前面的对象来定义后续每个对象。</p>
</li>
</ul>
<p>所谓递归，是指被定义的对象出现在定义本身中。在现实生活中经常会出现自我参照的情况，尽管这种情况没有立即被识别出来。例如，假设定义祖先，可以用这样的表达式：</p>
<p><code>祖先 = （父母） + （父母的祖先）</code></p>
<p>请注意上述定义中的<strong>祖先</strong>，在它自己的定义中也出现。这是一个递归的定义。</p>
<p>在编程中，递归有一个非常精确的含义。它指的是一种编码技术，是函数对自身的调用。</p>
<h2 id="为什么使用递归？"><a href="#为什么使用递归？" class="headerlink" title="为什么使用递归？"></a>为什么使用递归？</h2><p>大多数编程问题是不需要递归就可以解决的。所以严格说来，递归通常是不必须的。</p>
<p>然而，有些情况特别适合用<strong>自我参照</strong>进行定义，例如，上面所示的“祖先”的定义，如果你要写一段程序实现这个定义，用递归可能是一种简约的途径。</p>
<p>对树状数据结构的遍历也是应用递归的恰当例子。因为这类数据是嵌套结构，很容易用递归定义。遍历嵌套结构的非递归算法可能会有点笨拙，而递归解决方案则相对优雅。</p>
<p>另一方面，递归并非对每一种情况都适用。以下是需要考虑的其他因素：</p>
<ul>
<li><p>有些问题虽然可以使用递归方案来解决，但实际上会显得很笨拙，而不是优雅。</p>
</li>
<li><p>递归实现通常比非递归实现消耗更多的内存。</p>
</li>
<li><p>在某些情况下，使用递归可能会导致执行时间较长。</p>
</li>
</ul>
<p>通常，代码的可读性是编程中应该考虑的第一因素。是否使用递归，要视具体情况而定。下面的示例将帮助你了解何时应该选择递归。</p>
<h2 id="Python-中的递归"><a href="#Python-中的递归" class="headerlink" title="Python 中的递归"></a>Python 中的递归</h2><p>当你在 Python 中调用一个函数时，解释器会创建一个新的局部命名空间，这样在该函数中定义的名称就不会与其他地方定义的相同名称冲突。一个函数可以调用另一个函数，即使它们都定义了具有相同名称的对象，也能正常工作，因为这些对象存在于单独的命名空间中。</p>
<p>这一点同样适用于在同一函数中同时运行多个实例。例如以下定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    function()</span><br></pre></td></tr></table></figure>

<p>当 <code>function()</code> 第一次执行时，Python 会创建一个命名空间，并在该命名空间中把 <code>x</code> 赋值为 <code>10</code> 。然后 <code>function()</code> 调用自身——递归。第二次运行 <code>function()</code> 时，解释器会创建第二个命名空间，并将 <code>10</code> 赋值给 <code>x</code> 。名称 <code>x</code> 的这两个实例彼此不同，可以共存而不发生冲突，因为它们位于不同的命名空间中。</p>
<p>不幸的是，如果执行上面的所定义的 <code>function()</code> 函数，会得到不太好的结果，正如下面的<a href="https://realpython.com/python-traceback/" target="_blank" rel="noopener">回溯</a>所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> function</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> function</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> function</span><br><span class="line">  [Previous line repeated <span class="number">996</span> more times]</span><br><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure>

<p>如前所述，<code>function()</code> 函数在理论上将永远持续下去，一遍又一遍地调用自己，而没有任何返回值。当然，在实践中，应该没有这样的递归。电脑只有那么多内存，那些内存最终也会耗尽。</p>
<p>Python 不允许出现这种情况，解释器限制了函数可以对自身进行递归式调用的最大次数，当达到该极限时，会引发 <code>RecursionError</code> 异常，如上所示。</p>
<p><strong>技术说明：</strong>可以通过名 sys 模块中的 <code>getrecursionlimit()</code> 函数来了解 Python 的递归次数限制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> getrecursionlimit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrecursionlimit()</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>以上是限制的默认值，也可以通过 <code>setrecursionlimit()</code> 函数修改此值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setrecursionlimit(<span class="number">2000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getrecursionlimit()</span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>可以把这个限制值设置得非常大，但不能使它无限大。</p>
<p>一个函数无休止地递归式调用自己并没有多大用处。这让人想起你有时在洗发水瓶子上看到的说明：“揉至起泡沫，清洗，重复。”如果你真的按照这些说明去做，你会永远在洗头！</p>
<p>这种逻辑上的缺陷显然出现在一些洗发水制造商身上，因为有些洗发水瓶子上写着“揉至起泡沫，清洗，必要时重复”。这为说明书提供了终止条件。想必，你最终会觉得你的头发足够干净，不需要额外的重复，洗头的过程就可以结束了。</p>
<p>同样的道理，递归式调用自身的函数必须有一个事件使其最终停止调用。递归函数通常遵循以下模式：</p>
<ul>
<li><p>有一个或多个终止条件可以直接得到结果，而不需要进一步递归。</p>
</li>
<li><p>每次递归调用都会使结果逐渐接近终止条件。</p>
</li>
</ul>
<h2 id="开始：倒数至零"><a href="#开始：倒数至零" class="headerlink" title="开始：倒数至零"></a>开始：倒数至零</h2><p>第一个示例是一个名为 <code>countdown()</code> 的函数，它以正数作为输入参数，并将指定参数中的数字按倒数的顺序输出至零：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span>             <span class="comment"># Terminate recursion</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        countdown(n - <span class="number">1</span>)   <span class="comment"># Recursive call</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>请注意 <code>countdown()</code> 函数的终止条件：</p>
<ul>
<li><p>当 <code>n</code> 为零时，符合终止条件，此时递归停止。</p>
</li>
<li><p>在递归调用中，参数为 <code>n-1</code> （ <code>n</code> 是当前值），因此每个递归都更接近终止条件。</p>
</li>
</ul>
<p><strong>注意：</strong>为简单起见，<code>countdown()</code> 不检查其参数的有效性。如果 <code>n</code> 是非整数或负数，则会出现 <code>RecursionError</code> 异常，因为它完全不不符合终止条件。</p>
<p>上面的 <code>countdown()</code>  版本突显了终止条件和递归调用，但有一种更简洁的表达方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        countdown(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>下面是一个可能的非递归实现，用于比较:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        print(n)</span><br><span class="line"><span class="meta">... </span>        n -= <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，非递归解决方案至少与递归解决方案一样清晰直观，而且可能更为简洁。</p>
<h2 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h2><p>下一个例子涉及“阶乘”的数学概念。正整数 <code>n</code> 的阶乘，表示为 $n！$​ ，定义如下：</p>
<p>$$n! = 1\times2\times\cdots\times n$$</p>
<p>换句话说，$n！$​​ 是从 $1$​ 到 $n$​ 的所有整数的乘积。</p>
<p>因此，阶乘适合于用递归定义，很多编程的数据都会用这个作为示例说明递归。</p>
<p>$$n!=\begin{cases}1 &amp; n=0,1\n\times(n-1)! &amp; n\ge 2\end{cases}$$​</p>
<p>与上面的示例一样，终止条件是不需要递归就可以实现的；更复杂的事件则可简化，也就是将其简化为终止条件之一:</p>
<ul>
<li><p>$n = 0$​​ 或 $n = 1$​​ 时是终止条件，不需要递归就可以得到阶乘的结果。</p>
</li>
<li><p>如果 $n\gt1$​​​ ，根据 $(n - 1)!$​​​ 来定义 $n!$​​​ ，这样通过递归逐步接近终止条件。</p>
</li>
</ul>
<p>例如 $4!$​ 的递归计算过程是这样的：</p>
<p><img src="https://gitee.com/qiwsir/images/raw/master/2021-9-6/1630904603247-factorial.png" alt=""></p>
<p>计算 $4!$​​ 、$3!$​​ 和 $2!$​​  ，直到 $n = 1$ 时的终止条件结束递归。此时，无需进一步递归就可以计算 $1!$ 。后续的延迟计算将运行到最终完成。</p>
<h3 id="编写阶乘函数"><a href="#编写阶乘函数" class="headerlink" title="编写阶乘函数"></a>编写阶乘函数</h3><p>下面的函数就是按照以上四项编写的计算阶乘的 Python 递归函数。它是多么简洁、而且多么准确地反映了上面的定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>为了弄清楚函数的执行过程，可以用 <code>print()</code> 将函数执行过程中的结果打印出来，这样可以对调用和返回序列有一个更清晰的理解:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">f"factorial() called with n = <span class="subst">&#123;n&#125;</span>"</span>)</span><br><span class="line"><span class="meta">... </span>    return_value = <span class="number">1</span> <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">else</span> n * factorial(n <span class="number">-1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">f"-&gt; factorial(<span class="subst">&#123;n&#125;</span>) returns <span class="subst">&#123;return_value&#125;</span>"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> return_value</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">4</span>)</span><br><span class="line">factorial() called <span class="keyword">with</span> n = <span class="number">4</span></span><br><span class="line">factorial() called <span class="keyword">with</span> n = <span class="number">3</span></span><br><span class="line">factorial() called <span class="keyword">with</span> n = <span class="number">2</span></span><br><span class="line">factorial() called <span class="keyword">with</span> n = <span class="number">1</span></span><br><span class="line">-&gt; factorial(1) returns 1</span><br><span class="line">-&gt; factorial(2) returns 2</span><br><span class="line">-&gt; factorial(3) returns 6</span><br><span class="line">-&gt; factorial(4) returns 24</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>注意递归调用的累积过程。在返回任何一个递归调用的函数结果之前，该函数被 <code>n = 4, 3, 2, 1</code> 连续调用。最后，当 <code>n = 1</code> 时，无需再递归即可解决问题。然后每个累积起来的递归调用都会展开，从最外层的调用返回 <code>1</code>, <code>2</code>, <code>6</code>，最后返回 <code>24</code>。</p>
<p>如果不用递归，其实也能实现阶乘，下面用 <code>for</code> 循环写一个实现阶乘的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    return_value = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>        return_value *= i</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> return_value</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>还可以使用 Python 的 <code>reduce()</code> 函数来实现阶乘，此函数要从 <code>functools</code> 模块导入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * y, range(<span class="number">1</span>, n + <span class="number">1</span>) <span class="keyword">or</span> [<span class="number">1</span>])</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>这表明如果一个问题可以用递归来解决，那么也可能有几个非递归解决方案。你的选择通常会基于代码的可读性和直观性。</p>
<p>另一个需要考虑的因素是执行速度。递归和非递归解决方案之间可能存在显著的性能差异。</p>
<h3 id="比较不同实现方式的速度"><a href="#比较不同实现方式的速度" class="headerlink" title="比较不同实现方式的速度"></a>比较不同实现方式的速度</h3><p>要计算函数的执行时间，可以使用 <code>timeit</code> 模块中的 <code>timeit()</code> 的函数，这个函数支持多种不同的调用形式，此处将用下面的方式调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit(&lt;command&gt;, setup=&lt;setup_string&gt;, number=&lt;iterations&gt;)</span><br></pre></td></tr></table></figure>

<p>执行 <code>timeit()</code> 函数时，首先调用 <code>setup</code> 参数的值 <code>&lt;setup_string&gt;</code> 中指令，然后按照 <code>number</code> 参数的值执行 <code>&lt;command&gt;</code> 操作  <code>&lt;iterations&gt;</code> 次，并报告累计的执行时间（以秒为单位）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"print(string)"</span>, setup=<span class="string">"string='foobar'"</span>, number=<span class="number">100</span>)</span><br><span class="line">foobar</span><br><span class="line">foobar</span><br><span class="line">foobar</span><br><span class="line">   .</span><br><span class="line">   . [<span class="number">100</span> repetitions]</span><br><span class="line">   .</span><br><span class="line">foobar</span><br><span class="line"><span class="number">0.03347089999988384</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>setup</code> 参数实现了对变量 <code>string</code> 赋值为 <code>foobar</code> 的操作。然后将 <code>print(string)</code> 指令执行 <code>number=100</code> 此。最终显示执行时间是 <code>0.03347</code> s （大于 $\frac{3}{100} s$​ ）。</p>
<p>下面使用 <code>timeit()</code> 来比较上面实现阶乘三种方式：递归、for 循环和 <code>reduce()</code> 函数。在每种情况下，变量 <code>setup_string</code> 是字符串，其中定义了相关的 <code>factorial()</code> 函数。然后，<code>timeit()</code> 执行 <code>factorial(4)</code> 总共1000万次，并报告结果。</p>
<p>首先，测试递归版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup_string = <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>print("Recursive:")</span></span><br><span class="line"><span class="string"><span class="meta">... </span>def factorial(n):</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    return 1 if n &lt;= 1 else n * factorial(n - 1)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"factorial(4)"</span>, setup=setup_string, number=<span class="number">10000000</span>)</span><br><span class="line">Recursive:</span><br><span class="line"><span class="number">4.957105500000125</span></span><br></pre></td></tr></table></figure>

<p>接下来测试 for 循环的实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup_string = <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>print("Iterative:")</span></span><br><span class="line"><span class="string"><span class="meta">... </span>def factorial(n):</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    return_value = 1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    for i in range(2, n + 1):</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        return_value *= i</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    return return_value</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"factorial(4)"</span>, setup=setup_string, number=<span class="number">10000000</span>)</span><br><span class="line">Iterative:</span><br><span class="line"><span class="number">3.733752099999947</span></span><br></pre></td></tr></table></figure>

<p>最后测试 <code>reduce()</code> 版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup_string = <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>from functools import reduce</span></span><br><span class="line"><span class="string"><span class="meta">... </span>print("reduce():")</span></span><br><span class="line"><span class="string"><span class="meta">... </span>def factorial(n):</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    return reduce(lambda x, y: x * y, range(1, n + 1) or [1])</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"factorial(4)"</span>, setup=setup_string, number=<span class="number">10000000</span>)</span><br><span class="line">reduce():</span><br><span class="line"><span class="number">8.101526299999932</span></span><br></pre></td></tr></table></figure>

<p>从上述测试可知，用 for 循环的迭代是最快的，尽管递归解决方案也不算太慢，倒是 <code>reduce()</code> 的实现是最慢的。如果你在自己的计算机上尝试这些示例，可能会有所不同。与示例相比，你所花费的时间肯定有所不同，甚至你所得出的排名也可能有所不同。</p>
<p>这有关系吗? 迭代和使用 <code>reduce()</code> 的实现在执行时间上几乎有4秒的差异，但我们需要1000万个调用才能看到这一差异。</p>
<p>如果要多次调用一个函数，那么在选择实现时可能需要考虑执行速度。另一方面，如果函数运行的频率相对较低，那么执行时间上的差异或许可以忽略不计。这种情况下，你所选择的实现最好能非常清楚地表达解决问题的方案——即代码的可读性是第一位的。</p>
<p>对于阶乘，从上述测试结果来看，递归实现是一个合理的选择。</p>
<p>坦白地说，如果你用 Python 编码，你根本不需要实现阶乘函数，因为标准库的 <code>math</code> 模块中已经提供了阶乘函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import factorial</span><br><span class="line">&gt;&gt;&gt; factorial(4)</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>也许你会有兴趣了解它在计时测试中的表现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; setup_string &#x3D; &quot;from math import factorial&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from timeit import timeit</span><br><span class="line">&gt;&gt;&gt; timeit(&quot;factorial(4)&quot;, setup&#x3D;setup_string, number&#x3D;10000000)</span><br><span class="line">0.3724050999999946</span><br></pre></td></tr></table></figure>

<p>哇! 与上面显示的其他三种实现相比，<code>math.factorial()</code> 的运行时间大约缩短了10倍。</p>
<p>用 C 语言实现的函数几乎总是比用纯 Python 实现的相应函数运行速度更快。</p>
<h2 id="遍历嵌套列表"><a href="#遍历嵌套列表" class="headerlink" title="遍历嵌套列表"></a>遍历嵌套列表</h2><p>下一个示例涉及访问嵌套式列表结构中的每个项。思考下面的 Python 列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">names = [</span><br><span class="line">    "Adam",</span><br><span class="line">    [</span><br><span class="line">        "Bob",</span><br><span class="line">        [</span><br><span class="line">            "Chet",</span><br><span class="line">            "Cat",</span><br><span class="line">        ],</span><br><span class="line">        "Barb",</span><br><span class="line">        "Bert"</span><br><span class="line">    ],</span><br><span class="line">    "Alex",</span><br><span class="line">    [</span><br><span class="line">        "Bea",</span><br><span class="line">        "Bill"</span><br><span class="line">    ],</span><br><span class="line">    "Ann"</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如下图所示，<code>names</code> 包含两个子列表。第一个子列表本身包含另一个子列表:</p>
<p><img src="https://gitee.com/qiwsir/images/raw/master/2021-9-6/1630909715653-jsturtz-nested-list.png" alt=""></p>
<p>假设你想统计这个列表中叶子元素（即最低级别的字符串对象）的数量，就好像你已经将列表展开一样。叶子元素包括 <code>&quot;Adam&quot;、&quot;Bob&quot;、&quot;Chet&quot;、&quot;Cat&quot;、&quot;Barb&quot;、&quot;Bert&quot;、&quot;Alex&quot;、&quot;Bea&quot;、&quot;Bill&quot;、&quot;Ann&quot;</code> ，所以答案应该是“10”。</p>
<p>如果用 <code>len()</code> 函数并不能得出正确的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(names)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>len()</code> 函数统计 <code>names</code> 顶层的对象个数，即三个叶元素 <code>&quot;Adam&quot;、&quot;Alex&quot;</code> 和 <code>&quot;Ann&quot;</code> ，以及两个子列表 <code>[&quot;Bob&quot;，[&quot;Chet&quot;，&quot;Cat&quot;]，&quot;Barb&quot;，&quot;Bert&quot;]</code> 和 <code>[&quot;Bea&quot;，&quot;Bill&quot;]</code> ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(names):</span><br><span class="line"><span class="meta">... </span>    print(index, item)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Adam</span><br><span class="line"><span class="number">1</span> [<span class="string">'Bob'</span>, [<span class="string">'Chet'</span>, <span class="string">'Cat'</span>], <span class="string">'Barb'</span>, <span class="string">'Bert'</span>]</span><br><span class="line"><span class="number">2</span> Alex</span><br><span class="line"><span class="number">3</span> [<span class="string">'Bea'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"><span class="number">4</span> Ann</span><br></pre></td></tr></table></figure>

<p>这里需要的是一个遍历整个列表结构（包括子列表）的函数。该算法是这样的:</p>
<ol>
<li>遍历列表，依次检查每一项。</li>
<li>如果找到一个叶元素，则将其添加到累积计数中。</li>
<li>如果遇到子列表，执行以下操作:<ol>
<li>进入到该子列表，并用类似的方式遍历它。</li>
<li>一旦你遍历了子列表，就返回，将子列表中的元素添加到累积计数中，并从结束的地方继续遍历父列表。</li>
</ol>
</li>
</ol>
<p>注意这里所描述的自引用性质: 遍历列表。 如果遇到子列表，则用类似的方式遍历此列表，这种情况就需要递归!</p>
<h3 id="用递归遍历嵌套列表"><a href="#用递归遍历嵌套列表" class="headerlink" title="用递归遍历嵌套列表"></a>用递归遍历嵌套列表</h3><p>递归非常适合解决这个问题。首先要确定给定的列表项是否是叶子。为此，可以使用内置的 Python 函数 <code>isinstance()</code> 。</p>
<p>在 <code>names</code> 列表中，如果一个项是 <code>list</code> 类型的实例，那么它就是一个子列表。否则，它就是一个叶子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names</span><br><span class="line">[<span class="string">'Adam'</span>, [<span class="string">'Bob'</span>, [<span class="string">'Chet'</span>, <span class="string">'Cat'</span>], <span class="string">'Barb'</span>, <span class="string">'Bert'</span>], <span class="string">'Alex'</span>, [<span class="string">'Bea'</span>, <span class="string">'Bill'</span>], <span class="string">'Ann'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names[<span class="number">0</span>]</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(names[<span class="number">0</span>], list)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names[<span class="number">1</span>]</span><br><span class="line">[<span class="string">'Bob'</span>, [<span class="string">'Chet'</span>, <span class="string">'Cat'</span>], <span class="string">'Barb'</span>, <span class="string">'Bert'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(names[<span class="number">1</span>], list)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">[<span class="string">'Chet'</span>, <span class="string">'Cat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(names[<span class="number">1</span>][<span class="number">1</span>], list)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="string">'Chet'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(names[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], list)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>接下来，编写实现函数，该函数用于统计列表中的叶子元素，并递归地计算子列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_leaf_items</span><span class="params">(item_list)</span>:</span></span><br><span class="line">    <span class="string">"""Recursively counts and returns the</span></span><br><span class="line"><span class="string">       number of leaf items in a (potentially</span></span><br><span class="line"><span class="string">       nested) list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">        <span class="keyword">if</span> isinstance(item, list):</span><br><span class="line">            count += count_leaf_items(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>下面用几个参数传入 <code>count_leaf_items()</code> ，包括上面定义的 <code>names</code> 列表，会得到以下结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_leaf_items([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_leaf_items([<span class="number">1</span>, [<span class="number">2.1</span>, <span class="number">2.2</span>], <span class="number">3</span>])</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_leaf_items([])</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_leaf_items(names)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>与阶乘示例一样，添加一些 <code>print()</code> 语句有助于演示递归调用的顺序和返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_leaf_items</span><span class="params">(item_list)</span>:</span></span><br><span class="line">    <span class="string">"""Recursively counts and returns the</span></span><br><span class="line"><span class="string">       number of leaf items in a (potentially</span></span><br><span class="line"><span class="string">       nested) list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">f"List: <span class="subst">&#123;item_list&#125;</span>"</span>)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> item_list:</span><br><span class="line">        <span class="keyword">if</span> isinstance(item, list):</span><br><span class="line">            print(<span class="string">"Encountered sublist"</span>)</span><br><span class="line">            count += count_leaf_items(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f"Counted leaf item \"<span class="subst">&#123;item&#125;</span>\""</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"-&gt; Returning count <span class="subst">&#123;count&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>对上述示例的解释如下：</p>
<ul>
<li><p><strong>第9行:</strong>  <code>isinstance(item, list)</code> 的值是 <code>True</code> ，所以 <code>count_leaf_items()</code> 找到了一个子列表。</p>
</li>
<li><p>*<em>第11行: *</em>函数通过调用自身实现递归，继续统计子列表中的项，然后将结果添加到累计的总数中。</p>
</li>
<li><p>*<em>第12行: *</em> <code>isinstance(item, list)</code> 的值是 <code>False</code> 时，<code>count_leaf_items()</code> 遇到了一个叶子项。</p>
</li>
<li><p>*<em>第14行: *</em>将累计总数增加1，以计入叶子项。</p>
</li>
</ul>
<p><strong>注</strong>： 为简单起见, 该实现假设传递给 <code>count_leaf_items()</code> 的列表只包含叶子项或子列表, 而不包含任何其他类型的复合对象，如：字典或元组。</p>
<p>The output from <code>count_leaf_items()</code> when it’s executed on the <code>names</code> list now looks like this:</p>
<p>现在，对 <code>names</code> 列表执行 <code>count_leaf_items()</code> 时的输出是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_leaf_items(names)</span><br><span class="line">List: [<span class="string">'Adam'</span>, [<span class="string">'Bob'</span>, [<span class="string">'Chet'</span>, <span class="string">'Cat'</span>], <span class="string">'Barb'</span>, <span class="string">'Bert'</span>], <span class="string">'Alex'</span>, [<span class="string">'Bea'</span>, <span class="string">'Bill'</span>], <span class="string">'Ann'</span>]</span><br><span class="line">Counted leaf item <span class="string">"Adam"</span></span><br><span class="line">Encountered sublist</span><br><span class="line">List: [<span class="string">'Bob'</span>, [<span class="string">'Chet'</span>, <span class="string">'Cat'</span>], <span class="string">'Barb'</span>, <span class="string">'Bert'</span>]</span><br><span class="line">Counted leaf item <span class="string">"Bob"</span></span><br><span class="line">Encountered sublist</span><br><span class="line">List: [<span class="string">'Chet'</span>, <span class="string">'Cat'</span>]</span><br><span class="line">Counted leaf item <span class="string">"Chet"</span></span><br><span class="line">Counted leaf item <span class="string">"Cat"</span></span><br><span class="line">-&gt; Returning count 2</span><br><span class="line">Counted leaf item <span class="string">"Barb"</span></span><br><span class="line">Counted leaf item <span class="string">"Bert"</span></span><br><span class="line">-&gt; Returning count 5</span><br><span class="line">Counted leaf item <span class="string">"Alex"</span></span><br><span class="line">Encountered sublist</span><br><span class="line">List: [<span class="string">'Bea'</span>, <span class="string">'Bill'</span>]</span><br><span class="line">Counted leaf item <span class="string">"Bea"</span></span><br><span class="line">Counted leaf item <span class="string">"Bill"</span></span><br><span class="line">-&gt; Returning count 2</span><br><span class="line">Counted leaf item <span class="string">"Ann"</span></span><br><span class="line">-&gt; Returning count 10</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>每次对 <code>count_leaf_items()</code> 的调用终止时，都会返回叶子的计数，这些叶子元素在传给该函数的列表中。顶层调用返回 <code>10</code> 。</p>
<h3 id="非递归遍历嵌套列表"><a href="#非递归遍历嵌套列表" class="headerlink" title="非递归遍历嵌套列表"></a>非递归遍历嵌套列表</h3><p>下面还是要展示一下用非递归方式实现对嵌套列表的遍历，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_leaf_items</span><span class="params">(item_list)</span>:</span></span><br><span class="line">    <span class="string">"""Non-recursively counts and returns the</span></span><br><span class="line"><span class="string">       number of leaf items in a (potentially</span></span><br><span class="line"><span class="string">       nested) list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    stack = []</span><br><span class="line">    current_list = item_list</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> i == len(current_list):</span><br><span class="line">            <span class="keyword">if</span> current_list == item_list:</span><br><span class="line">                <span class="keyword">return</span> count</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_list, i = stack.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(current_list[i], list):</span><br><span class="line">            stack.append([current_list, i])</span><br><span class="line">            current_list = current_list[i]</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对相同列表上执行这个非递归版本的 <code>count_leaf_items()</code> 函数，则会得到相同的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; count_leaf_items([1, 2, 3, 4])</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; count_leaf_items([1, [2.1, 2.2], 3])</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; count_leaf_items([])</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; count_leaf_items(names)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; # Success!</span><br></pre></td></tr></table></figure>

<p>这个函数中用栈来处理嵌套的子列表，当函数循环到一个子列表时，将父列表及子列表在父列表中的索引推送到栈里。一旦对子列表中的叶子元素完成计数，就会从栈中将父列表和索引删除并获得其返回值，这样就可以在停止的地方继续计算。</p>
<p>实际上，在递归实现中也会发生同样的事情。当你递归式调用函数时，Python 会将正在执行的实例的状态保存在栈上，以便可以运行递归调用。当递归调用完成时，状态将从栈中弹出，从而让中断的实例可以继续。这是相同的概念，但是在使用递归时，是 Python 自动完成了状态保存工作。</p>
<p>请注意，与非递归版本相比，递归代码是多么简洁易读：</p>
<p><img src="https://gitee.com/qiwsir/images/raw/master/2021-9-7/1630995953038-comparison.png" alt=""></p>
<p>比较递归式嵌套列表的遍历与非递归式嵌套列表的遍历</p>
<p>在这种情况下，使用递归绝对是一种优势。</p>
<h2 id="检测回文"><a href="#检测回文" class="headerlink" title="检测回文"></a>检测回文</h2><p>选择是否使用递归来解决问题在很大程度上取决于问题的性质。例如，阶乘自然可用递归实现，但用 for 循环也相当简单。这二者选谁，完全由开发者自己决定。</p>
<p>对于前面的遍历列表则是另一回事，对于该问题，显然递归非常优雅，而非递归解决方案则很麻烦。</p>
<p>下面再举一个检测回文的示例，如果使用递归解决这个问题，可以说是愚蠢的。</p>
<p><strong>回文</strong>是一个单词，它从前往后读和从后往前读是一样的，例如：Racecar、Level、Kayak、Reviver、Civic</p>
<p>如果让你设计一个算法来判断一个字符串是否是回文的，你可能会想出类似于“反转字符串，看看它是否和原来一样”这样的方案——没有比这更简单的了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(word)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Return True if word is a palindrome, False if not."""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> word == word[::<span class="number">-1</span>]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"foo"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"racecar"</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"troglodyte"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"civic"</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这种方式又清楚又简洁。几乎不需要寻找替代方式。但为了好玩，请考虑一下用递归实现回文检测：</p>
<ul>
<li><p>终止条件：空字符串以及单个字符，都可以视为回文。</p>
</li>
<li><p>递归：</p>
<p>长度大于或等于2个字符的字符串，如果同时满足以下两个条件，则为回文：</p>
<ol>
<li><p>第一个字符和最后一个字符相同。</p>
</li>
<li><p>第一个字符和最后一个字符之间的子字符串是回文。</p>
</li>
</ol>
</li>
</ul>
<p>Slicing is your friend here as well. For a string <code>word</code>, indexing and slicing give the following substrings:</p>
<p>字符串的切片也是有帮助的。对于字符串 <code>&quot;word&quot;</code> ，索引和切片将给出以下子字符串：</p>
<ul>
<li><p>第一个字符是 <code>word[0]</code> 。</p>
</li>
<li><p>最后一个字符是 <code>word[-1]</code> 。</p>
</li>
<li><p>第一个和最后一个字符之间的子字符串是 <code>word[1:-1]</code> 。</p>
</li>
</ul>
<p>所以可以像下面这样用递归定义函数 <code>is_palindrome()</code> 来判断一个字符串是否为回文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(word)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Return True if word is a palindrome, False if not."""</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(word) &lt;= <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> word[<span class="number">0</span>] == word[<span class="number">-1</span>] <span class="keyword">and</span> is_palindrome(word[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Base cases</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">""</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"a"</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Recursive cases</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"foo"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"racecar"</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"troglodyte"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_palindrome(<span class="string">"civic"</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>思考递归问题是一个有趣的练习，尽管它有时候不是很有必要。</p>
<h2 id="Quicksort-排序"><a href="#Quicksort-排序" class="headerlink" title="Quicksort 排序"></a>Quicksort 排序</h2><p>最后一个示例就像嵌套列表的遍历一样，是一个很好的问题示例，它也很自然地使用递归方法。Quicksort 算法是英国计算机科学家 Tony Hoare 于1959年开发的一种高效排序算法。</p>
<p>Quicksort 是一种<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" target="_blank" rel="noopener">分而治之算法</a>。假设有一个待排序的列表。首先从列表中选出一项，称之为<strong>基准</strong>（pivot），它可以是列表中的任意一项。然后，根据基准，将列表<strong>分区</strong>（partition），划分为比基准小和比基准大两部分，即得到了两个子列表。再对子列表递归排序。具体算法步骤如下：</p>
<ul>
<li><p>选择基准。</p>
</li>
<li><p>根据基准，将列表划分为两个子列表：</p>
<ol>
<li><p>子列表1：小于基准的项组成</p>
</li>
<li><p>子列表2：大于基准的项组成</p>
</li>
</ol>
</li>
<li><p>以递归方法，对子列表进行实施 Quicksort 排序。</p>
</li>
</ul>
<p>每次分区都会产生更小的子列表，所以该算法是简化法。基本时间发生在子列表为空或只有一个元素时，因为这些元素本身是有序的。</p>
<h3 id="选择基准"><a href="#选择基准" class="headerlink" title="选择基准"></a>选择基准</h3><p>无论以列表中的哪一项为基准，Quicksort 算法都能执行，但有些选择比另一些要好。请记住，在分区时，会创建两个子列表：一个子列表中的项小于基准，另一个子列表中的项大于基准。理想情况下，两个子列表的长度大致相等。</p>
<p>假设要排序的初始列表包含八项。如果每个分区都会产生长度大致相等的子列表，则可以通过三个步骤达到终止条件（如下图所示）。</p>
<p><img src="https://gitee.com/qiwsir/images/raw/master/2021-9-7/1630996136433-pivot.png" alt=""></p>
<center>最优分区示意图</center>

<p>另一方面，如果选择的基准特别不走运，则每个分区产生的两个子列表中，其中一个子列表包含基准以外的所有原始项，另一个子列表为空。在这种情况下，需要七个步骤才能将列表简化为终止条件：</p>
<p><img src="https://gitee.com/qiwsir/images/raw/master/2021-9-7/1630996437182-suboptimal.png" alt=""></p>
<center>次优分区示意图</center>

<p>在第一种情况下，Quicksort 算法将更有效。但是，为了从全局着手选择最佳基准项，需要提前了解用于排序的数据的特点。在任何情况下，没有任何一个选择对所有情况都是最好的。因此，如果要编写一个 Quicksort 函数来处理一般情况，那么基准的选择就有点随意了。</p>
<p>如果列表中的数据是随机分布的，那么以第一项与最后一项为基准是常见的选择。然而，如果数据已经被排序，或者几乎被排序了，这种方法将导致像上面所示的次优分区。为了避免这种情况，一些 Quicksort 算法选择列表中的中间项作为基准。</p>
<p>另一个做法是找到列表中第一项、最后一项和中间项的中位数，并将其用作基准，这是下面的示例代码中所用的策略。</p>
<h3 id="实现分区"><a href="#实现分区" class="headerlink" title="实现分区"></a>实现分区</h3><p>一旦选择了基准，下一步就是对列表进行分区。同样，目标是创建两个子列表，一个子列表包含小于透视项的项，另一个子列表包含大于透视项的项。</p>
<p>你可以直接在原有列表上完成。换言之，通过对列表成员项进行交换，打乱列表中的项的次序，直到基准项位于中间，所有小于它的项位于其左侧，所有大于它的项位于其右侧。然后，运用递归算法对子列表进行 Quicksort 排序，就会将列表的切片传递到基准项的左侧和右侧。</p>
<p>或者，你可以使用 Python 的列表的方法来创建新的列表，而不是在原来的列表上进行操作。这是下面代码中采用的方法。算法如下：</p>
<ul>
<li><p>以第一项、最后一项和中间项的中位数（中值）作为所选定的基准。</p>
</li>
<li><p>通过基准创建三个子列表：</p>
<ol>
<li>子列表1的成员是原始列表中小于基准的项</li>
<li>子列表2是由基准项本身构成</li>
<li>子列表3的成员是原始列表中大于基准的项</li>
</ol>
</li>
<li><p>对子列表1和子列表3分布进行递归式 Quicksort 。</p>
</li>
<li><p>将所有三个列表重新连接在一起。</p>
</li>
</ul>
<p>请注意，这里创建了一个仅含有基准的子列表，这种方法的一个优点是，它可以顺利地处理基准项多次出现在列表中的情况。在这种情况下，子列表2将有多个元素。</p>
<h3 id="实现-Quicksort"><a href="#实现-Quicksort" class="headerlink" title="实现 Quicksort"></a>实现 Quicksort</h3><p>现在基础工作已经就绪，就可以编写 Quicksort 算法的代码了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statistics</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> numbers</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = statistics.median(</span><br><span class="line">            [</span><br><span class="line">                numbers[<span class="number">0</span>],</span><br><span class="line">                numbers[len(numbers) // <span class="number">2</span>],</span><br><span class="line">                numbers[<span class="number">-1</span>]</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        items_less, pivot_items, items_greater = (</span><br><span class="line">            [n <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n &lt; pivot],</span><br><span class="line">            [n <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n == pivot],</span><br><span class="line">            [n <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n &gt; pivot]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            quicksort(items_less) +</span><br><span class="line">            pivot_items +</span><br><span class="line">            quicksort(items_greater)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>以下对 <code>quicksort()</code> 做必要的解释：</p>
<ul>
<li><p><strong>第4行：</strong>列表为空或只有一个元素的终止条件</p>
</li>
<li><p><strong>第7行至第13行：</strong>用三个数的中位数（中值）计算基准项</p>
</li>
<li><p><strong>第14行到第18行：</strong>创建表示三个分区的列表</p>
</li>
<li><p><strong>第20至24行：</strong>分区列表的递归排序和重新组合</p>
</li>
</ul>
<p><strong>注：</strong>这个例子的优点是简洁易懂。然而，它并不是最有效的实现。特别是：在第14行到第18行创建分区的部分，需要对列表进行三次独立的循环。从执行时间的角度来看，这不是最佳方案。</p>
<p>Here are some examples of <code>quicksort()</code> in action:</p>
<p>下面是调用 <code>quicksort()</code> 函数的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Base cases</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort([])</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort([<span class="number">42</span>])</span><br><span class="line">[<span class="number">42</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Recursive cases</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort([<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort([<span class="number">10</span>, <span class="number">-3</span>, <span class="number">21</span>, <span class="number">6</span>, <span class="number">-8</span>])</span><br><span class="line">[<span class="number">-8</span>, <span class="number">-3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">21</span>]</span><br></pre></td></tr></table></figure>

<p>为了便于测试，你可以定义一个简短的函数来生成一个由 <code>1</code> 到 <code>100</code> 的随机数字列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_numbers</span><span class="params">(length, minimum=<span class="number">1</span>, maximum=<span class="number">100</span>)</span>:</span></span><br><span class="line">    numbers = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(length):</span><br><span class="line">        numbers.append(random.randint(minimum, maximum))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers</span><br></pre></td></tr></table></figure>

<p>现在可以使用 <code>get_random_numbers()</code> 函数生成的结果测试排序函数 <code>quicksort()</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = get_random_numbers(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">24</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">84</span>, <span class="number">63</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">53</span>, <span class="number">64</span>, <span class="number">19</span>, <span class="number">89</span>, <span class="number">48</span>, <span class="number">7</span>, <span class="number">31</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">76</span>, <span class="number">91</span>, <span class="number">78</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort(numbers)</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">53</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">76</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">89</span>, <span class="number">91</span>, <span class="number">94</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = get_random_numbers(<span class="number">15</span>, <span class="number">-50</span>, <span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">-2</span>, <span class="number">14</span>, <span class="number">48</span>, <span class="number">42</span>, <span class="number">-48</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">-25</span>, <span class="number">14</span>, <span class="number">-14</span>, <span class="number">41</span>, <span class="number">-30</span>, <span class="number">-35</span>, <span class="number">36</span>, <span class="number">-5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort(numbers)</span><br><span class="line">[<span class="number">-48</span>, <span class="number">-35</span>, <span class="number">-30</span>, <span class="number">-25</span>, <span class="number">-14</span>, <span class="number">-5</span>, <span class="number">-2</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">44</span>, <span class="number">48</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort(get_random_numbers(<span class="number">10</span>, maximum=<span class="number">500</span>))</span><br><span class="line">[<span class="number">49</span>, <span class="number">94</span>, <span class="number">99</span>, <span class="number">124</span>, <span class="number">235</span>, <span class="number">287</span>, <span class="number">292</span>, <span class="number">333</span>, <span class="number">455</span>, <span class="number">464</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quicksort(get_random_numbers(<span class="number">10</span>, <span class="number">1000</span>, <span class="number">2000</span>))</span><br><span class="line">[<span class="number">1038</span>, <span class="number">1321</span>, <span class="number">1530</span>, <span class="number">1630</span>, <span class="number">1835</span>, <span class="number">1873</span>, <span class="number">1900</span>, <span class="number">1931</span>, <span class="number">1936</span>, <span class="number">1943</span>]</span><br></pre></td></tr></table></figure>

<p>要进一步理解 <code>quicksort()</code> 的工作原理，请参见下图。这里显示了对含有 12 个元素的列表进行排序时的递归过程。</p>
<p><img src="https://gitee.com/qiwsir/images/raw/master/2021-9-7/1631011983139-qsort.png" alt=""></p>
<center>Quicksort 算法原理解析</center>

<p>如上图所示，在原始列表中，第一个成员是 <code>31</code> 、中间的是 <code>92</code>、最后一个是 <code>28</code> , 这三个数值的中位数（中值）是 <code>31</code> ，故以它为基准。第一个分区由以下子列表组成:</p>
<table>
<thead>
<tr>
<th>子列表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[18, 3, 18, 11, 28]</code></td>
<td>小于基准的成员</td>
</tr>
<tr>
<td><code>[31]</code></td>
<td>基准本身</td>
</tr>
<tr>
<td><code>[72, 79, 92, 44, 56, 41]</code></td>
<td>大于基准的成员</td>
</tr>
</tbody></table>
<p>每个子列表随后以相同的方式再实施递归，并获得分区，直到所有子列表要么包含单个成员，要么为空。当递归调用返回时，列表将按排序的结果重组。注意，在左边倒数第二步中，基准项 <code>18</code> 在列表中出现了两次，因此基准项的子列表有两个成员。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>递归</strong>之旅到此就要结束了，递归的核心就是：函数对自身的调用。递归并非对所有的任务都适用，有些编程问题迫切需要使用递归，此时递归是一种很好用的技巧。</p>
<p>你现在应该能够很好地认识到何时调用递归，并准备好在需要递归时自信地使用它了。 如果你想了解更多关于Python递归的知识，请查看<a href="https://realpython.com/python-thinking-recursively/" target="_blank" rel="noopener">Python递归思维</a>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]. <a href="https://realpython.com/python-recursion/" target="_blank" rel="noopener">https://realpython.com/python-recursion/</a></p>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/05/06/what-is-debugging/">
        <span class="nav-arrow">← </span>
        
          调试及其重要性
        
      </a>
    
    
      <a class="nav-right" href="/2021/09/06/learn-program-right-way/">
        
          什么是学习编程的正确方法
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <!--% if (theme.qrcode) { %-->
      <div class="qrcode">
        <!--canvas id="share-qrcode"></!--canvas-->
        <img src="https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg" width=400>
        <p class="notice">关注微信公众号，读文章、听课程，提升技能</p>
      </div>
    <!--% } %-->
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#什么是递归"><span class="toc-nav-text">什么是递归</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#为什么使用递归？"><span class="toc-nav-text">为什么使用递归？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Python-中的递归"><span class="toc-nav-text">Python 中的递归</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#开始：倒数至零"><span class="toc-nav-text">开始：倒数至零</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#计算阶乘"><span class="toc-nav-text">计算阶乘</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#编写阶乘函数"><span class="toc-nav-text">编写阶乘函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#比较不同实现方式的速度"><span class="toc-nav-text">比较不同实现方式的速度</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#遍历嵌套列表"><span class="toc-nav-text">遍历嵌套列表</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#用递归遍历嵌套列表"><span class="toc-nav-text">用递归遍历嵌套列表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#非递归遍历嵌套列表"><span class="toc-nav-text">非递归遍历嵌套列表</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#检测回文"><span class="toc-nav-text">检测回文</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Quicksort-排序"><span class="toc-nav-text">Quicksort 排序</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#选择基准"><span class="toc-nav-text">选择基准</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实现分区"><span class="toc-nav-text">实现分区</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实现-Quicksort"><span class="toc-nav-text">实现 Quicksort</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#结论"><span class="toc-nav-text">结论</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#参考文献"><span class="toc-nav-text">参考文献</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://qiwsir.github.io/2021/06/03/recursion/';
    var banner = ''
    /*if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }*/
    //$('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by 老齐教室 | <a href='http://www.beian.miit.gov.cn' target="_blank" rel="noopener">苏ICP备13034293号-2 </a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>