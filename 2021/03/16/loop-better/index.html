<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="专注于编程技术和数据科学、人工智能">
  <meta name="keyword" content="人工智能, 数据科学, Python, 编程, 程序员, 开发者, web, 网站, 语言, 程序, UI, 美工, 设计师">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      深入理解循环和迭代 | 老齐教室
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


<meta name="generator" content="Hexo 4.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>老齐教室</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">书籍</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/courses/" class="item-link">课程</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">类目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/resources/" class="item-link">资源</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">书籍</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/courses/" class="menu-link">课程</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">类目</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/resources/" class="menu-link">资源</a>
            

          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            

          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  
  <!-- <div class="arrow-down">
    <a href="javascript:;"></a>
  </div> -->
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <h2>深入理解循环和迭代</h2>
    <p class="post-date">2021-03-16</p>
    <section class="markdown-content"><p>循环，特别是<code>for</code>循环，是Python中常见的语句，甚至于Guido van Rossum（Python创始人）在评论递归的时候说过在Python中“递归已死”，我想这句话的意思不是说在Python中不能用递归，而是说因为Python中的<code>for</code>循环语句足够强大，可以不考虑递归，而是用<code>for</code>循环实现原本用递归做的事情。</p>
<p>本来，在《Python大学实用教程》和《跟老齐学Python：轻松入门》两本书中都对<code>for</code>循环语句做了很完整地介绍，并且在这两本书中也有关于可迭代等概念，但是，如何将两者融合起来理解，从而能够更好地实现<code>for</code>循环，对新手还是有挑战的。</p>
<p>本文就在以上两本书所述基础上，从更深入和综合的角度进行阐述，以便能更好地使用<code>for</code>循环。</p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>在实用<code>for</code>循环中，特别是初学者，会遇到很多坑，这里列举几个，看看你是否遇到过？</p>
<h3 id="1、第二次无果"><a href="#1、第二次无果" class="headerlink" title="1、第二次无果"></a>1、第二次无果</h3><p>假设有一个数字组成的列表和一个生成器，生成器给出这些数字的平方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = (n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure>

<p>用<code>tuple</code>函数，将<code>squares</code>转化为元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple(squares) </span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">49</span>)</span><br></pre></td></tr></table></figure>

<p>现在，又向计算这个生成器对象<code>squares</code>里面所有数字的和，观察一下，应该能看出来，其和是<code>88</code>，然而：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(squares) </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里计算结果为<code>0</code>，是Python的BUG吗？</p>
<h3 id="2、检查无效"><a href="#2、检查无效" class="headerlink" title="2、检查无效"></a>2、检查无效</h3><p>再用下面的方法得到那个生成器对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = (n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure>

<p>如果检查<code>9</code>是否在<code>squares</code>生成器中，显然这是真的<code>True</code>。但是同样的检查如果再做一遍，就不是这个结果了——不可重复，不科学？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span> <span class="keyword">in</span> squares </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span> <span class="keyword">in</span> squares </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="3、解包"><a href="#3、解包" class="headerlink" title="3、解包"></a>3、解包</h3><p>创建一个包含两个键值对的字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = &#123;<span class="string">'apples'</span>: <span class="number">2</span>, <span class="string">'oranges'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>用多变量的赋值语句对字典解包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y &#x3D; counts</span><br></pre></td></tr></table></figure>

<p>先猜一下，这样做会有什么结果？报错，还是两个变量分别引用了两个键值对——引用键值对，兼职不可能吧，除非将键值对包裹在字典里。</p>
<p>但是，一没有报错，二没有返回键值对，而是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x </span><br><span class="line"><span class="string">'apples'</span></span><br></pre></td></tr></table></figure>

<p>这似乎也合乎情理和逻辑。</p>
<h2 id="复习for循环"><a href="#复习for循环" class="headerlink" title="复习for循环"></a>复习for循环</h2><p>温故而知新，先来回顾一下<code>for</code>循环。</p>
<p>严格地说，Python中的<code>for</code>循环并不“传统”，或者说不符合众多语言中所继承的C语言风格的<code>for</code>循环。</p>
<p>先看一看所谓的C语言风格的<code>for</code>循环，以JavaScript为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    print(numbers[i]) &#125;</span><br></pre></td></tr></table></figure>

<p>像人们熟知的JavaScript, C, C++, Java, PHP等很多编程语言的<code>for</code>循环，都是这个样子的，所以，不少人认为这样的才是真正的<code>for</code>循环。</p>
<p>但是，Python盲从，而是特立独行地创造了自己的<code>for</code>循环。它不是C语言风格的，而是Python风格的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>

<p>与传统的C语言风格的<code>for</code>循环不同，Python的<code>for</code>循环不需要创建索引，不需要对索引变量进行初始化，不需要进行边界检查，也不需要让索引递增。Python的<code>for</code>循环为我们完成了在<code>numbers</code>列表上循环的所有工作。</p>
<p>因此，Python中虽有<code>for</code>循环，但并非传统的C风格，那么其工作原理亦与之不同。</p>
<h2 id="可迭代对象和序列"><a href="#可迭代对象和序列" class="headerlink" title="可迭代对象和序列"></a>可迭代对象和序列</h2><p>在Python中，可迭代对象就是可以用<code>for</code>来循环的东西。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> some_iterable:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<p>序列是一种非常常见的可迭代对象，例如列表、元组和字符串都是序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coordinates = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = <span class="string">"hello there"</span></span><br></pre></td></tr></table></figure>

<p>序列是具有一组特定特征的可迭代对象，它们可以从<code>0</code>开始索引，并在比序列长度少一个元素的地方结束。它们有长度，并且可以切片。列表、元组、字符串和所有其他序列都是这样工作的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>] </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coordinates[<span class="number">2</span>] </span><br><span class="line"><span class="number">7</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words[<span class="number">4</span>] </span><br><span class="line"><span class="string">'o'</span></span><br></pre></td></tr></table></figure>

<p>Python中的很多东西都是可迭代对象，但并非所有的可迭代对象都是序列。集合、字典、文件和生成器都是可迭代对象，但它们都不是序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_dict = &#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k2'</span>: <span class="string">'v2'</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_file = open(<span class="string">'some_file.txt'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = (n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> my_set)</span><br></pre></td></tr></table></figure>

<p>因此，任何可以用<code>for</code>来循环的东西都是一个可迭代对象，例如序列，但是并非所有可迭代对象都是序列。</p>
<h2 id="Python的for循环"><a href="#Python的for循环" class="headerlink" title="Python的for循环"></a>Python的for循环</h2><p>前面已经显示了，Python的<code>for</code>循环不使用索引——这是不同于C语言分割的<code>for</code>循环之处。</p>
<p>不过，你可能会悄悄滴认为，如果非要用，Python的<code>for</code>循环肯定也能实现C语言风格，因为我们一向认为“C语言是任何东西的基础”。为此，我们使用<code>while</code> 循环和索引手动遍历一个可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> i &lt; len(numbers):</span><br><span class="line">    print(numbers[i])  </span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>很显然，上面的循环方式只适合于序列类对象，对其它的并非完全使用，比如字典、集合。</p>
<p>比如使用索引手动遍历一个集合，我们将看到报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = &#123;<span class="string">'lemon'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">0</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> i &lt; len(fruits): </span><br><span class="line"><span class="meta">... </span>    print(fruits[i]) </span><br><span class="line"><span class="meta">... </span>    i += <span class="number">1</span> </span><br><span class="line"><span class="meta">... </span>Traceback (most recent call last): File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">    TypeError: <span class="string">'set'</span> object does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></table></figure>

<p>集合不是序列，因此它们不支持索引。</p>
<p>在Python中，我们<em>不能</em>通过使用索引手动遍历每个可迭代对象。这对于不是序列的可迭代对象根本不起作用。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>在Python中，迭代器可以用于<code>for</code>循环。</p>
<p>什么是迭代器？它是驱动可迭代对象的一类对象。我们可以从任意可迭代对象那里生成迭代器。</p>
<p>这里有三个可迭代对象：集合、元组和字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; numbers &#x3D; &#123;1, 2, 3, 5, 7&#125; </span><br><span class="line">&gt;&gt;&gt; coordinates &#x3D; (4, 5, 7) </span><br><span class="line">&gt;&gt;&gt; words &#x3D; &quot;hello there&quot;</span><br></pre></td></tr></table></figure>

<p>可以用Python内置的<code>iter</code>函数用上面的可迭代对象生成迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(numbers) </span><br><span class="line">&lt;set_iterator object at <span class="number">0x7f2b9271c860</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(coordinates) </span><br><span class="line">&lt;tuple_iterator object at <span class="number">0x7f2b9271ce80</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(words) </span><br><span class="line">&lt;str_iterator object at <span class="number">0x7f2b9271c860</span>&gt;</span><br></pre></td></tr></table></figure>

<p>有了迭代器，就把它传给内置函数<code>next</code>，从而获得它的下一项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iterator = iter(numbers) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_iterator) </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_iterator) </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>每从迭代器中取出一项，那一项就从迭代器中“消失”了。如果到了迭代器的最后一项，还执行<code>next</code>，而实际上后面已经没有其他项了，这时候就会报出<code>StopIteration</code>异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(iterator) </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(iterator) </span><br><span class="line">Traceback (most recent call last):  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, </span><br><span class="line"><span class="keyword">in</span> &lt;module&gt; StopIteration</span><br></pre></td></tr></table></figure>



<h2 id="不用for的循环"><a href="#不用for的循环" class="headerlink" title="不用for的循环"></a>不用for的循环</h2><p>在了解了迭代器、以及<code>iter</code>和<code>next</code>函数后，我们将尝试手动遍历一个可迭代对象，而不使用<code>for</code>循环。</p>
<p>不用<code>for</code>，就得用<code>while</code>了，Python中只有这么两个循环语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funky_for_loop</span><span class="params">(iterable, action_to_do)</span>:</span>    </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">        action_to_do(item)</span><br></pre></td></tr></table></figure>

<p>为了去掉<code>for</code>，需要：</p>
<ol>
<li><p>根据给定的可迭代对象生成迭代器</p>
</li>
<li><p>从迭代器中重复获取下一项</p>
</li>
<li><p>如果成功获得了下一项，则相当于执行<code>for</code>循环了</p>
</li>
<li><p>如果在获取下一项时遇到“StopIteration”异常，则停止循环</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funky_for_loop</span><span class="params">(iterable, action_to_do)</span>:</span>    </span><br><span class="line">    iterator = iter(iterable)</span><br><span class="line">    done_looping = <span class="literal">False</span>    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done_looping:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            item = next(iterator)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            done_looping = <span class="literal">True</span>        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action_to_do(item)</span><br></pre></td></tr></table></figure>

<p>这里，其实是用<code>while</code>循环和迭代器重新发明了<code>for</code>循环。</p>
<p>上面的代码基本上定义了Python中循环的工作方式。如果你了解内置的<code>iter</code>和<code>next</code>函数在遍历对象时的工作方式，那么你就了解了Python的<code>for</code>循环是如何工作的，它们的工作过程是类似的。</p>
<p>实际上，通过上面的代码，不仅仅展示了<code>for</code>循环的工作原理，所有可迭代对象的循环都如此。</p>
<p>总结一下，<strong>迭代器协议</strong>是描述“Python中可迭代对象的循环如何工作的”的一种基本方式，它本质上是Python中<code>iter</code>和<code>next</code>函数所定义的，Python中所有形式的迭代都由迭代器协议提供支持。</p>
<p>迭代器协议也被用于<code>for</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> numbers:    </span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>

<p>多重赋值也使用迭代器协议：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = coordinates</span><br></pre></td></tr></table></figure>

<p>下面这种使用<code>*</code>的表达式也使用迭代器协议：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, *rest = numbers print(*numbers)</span><br></pre></td></tr></table></figure>

<p>许多内置函数依赖于迭代器协议：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_numbers = set(numbers)</span><br></pre></td></tr></table></figure>

<p>Python中任何与可迭代对象一起工作的东西都可能以某种方式使用迭代器协议。在Python中，每当你遍历一个可迭代对象时，都依赖于迭代器协议。</p>
<h2 id="生成器是迭代器"><a href="#生成器是迭代器" class="headerlink" title="生成器是迭代器"></a>生成器是迭代器</h2><p>迭代器看起来很酷，不过，它是不是用途有限呢？或者说作为普通的Python编程者，是不是不需要关心它呢？</p>
<p>非也。</p>
<p>迭代器很常见。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = (n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure>

<p>此处得到的<code>squares</code>是一个生成器，生成器也是迭代器，这意味着你可以对生成器调用<code>next</code>，以获取其下一项：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(squares) </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(squares) </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>用<code>for</code>循环同样可以遍历生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = (n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> squares: </span><br><span class="line"><span class="meta">... </span>    print(n) </span><br><span class="line"><span class="meta">... </span><span class="number">1</span> <span class="number">4</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>下面这句话，貌似废话，但是重要：<strong>迭代器是可迭代对象</strong>。</p>
<p>这就意味着，可以将迭代器对象作为<code>iter</code>函数的参数，生成一个新的迭代器对象。不是吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator1 = iter(numbers) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator2 = iter(iterator1)  <span class="comment"># 迭代器对象作为参数</span></span><br></pre></td></tr></table></figure>

<p>以上最终得到的<code>iterator2</code>是一个迭代器。不过，要注意，<code>iterator1</code>和<code>iterator2</code>的关系：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator1 <span class="keyword">is</span> iterator2 </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>iter</code>函数的参数如果是一个迭代器，返回对象仍然是该迭代器对象自身。</p>
<p>结论：迭代器是可迭代对象，所有迭代器都是自己的迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_iterator</span><span class="params">(iterable)</span>:</span>    </span><br><span class="line">    <span class="keyword">return</span> iter(iterable) <span class="keyword">is</span> iterable</span><br></pre></td></tr></table></figure>

<p>困惑了吗？</p>
<p>继续。</p>
<p>迭代器没有长度，因此无法索引。这个认识必须要建立起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator = iter(numbers) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(iterator) </span><br><span class="line">TypeError: object of type <span class="string">'list_iterator'</span> has no len() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator[<span class="number">0</span>] </span><br><span class="line">TypeError: <span class="string">'list_iterator'</span> object <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br></pre></td></tr></table></figure>

<p>从Python程序员的角度来看，使用迭代器可以做的唯一有用的事情就是：将迭代器传给内置的<code>next</code>函数、或遍历迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(iterator) </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iterator)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>如果我们第二次遍历迭代器，我们将一无所获：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(iterator) </span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>这就是说，迭代器可以认为是<strong>一次性</strong>的惰性的可迭代对象，这意味着它们只能遍历一次。</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Iterable?</th>
<th>Iterator?</th>
</tr>
</thead>
<tbody><tr>
<td>Iterable</td>
<td>✔️</td>
<td>❓</td>
</tr>
<tr>
<td>Iterator</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>Generator</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>List</td>
<td>✔️</td>
<td>❌</td>
</tr>
</tbody></table>
<p>正如上表中所示，可迭代对象并不总是迭代器，但迭代器总是可迭代对象：</p>
<p>所谓迭代器协议，即：</p>
<ol>
<li><p>可以作为<code>next</code>函数的参数，从而获得对象的下一项，或者在没有其他项时引发<code>StopIteration</code>异常。</p>
</li>
<li><p>可以作为<code>iter</code>函数的参数，并返回自身。</p>
</li>
</ol>
<p>反过来说，也成立：</p>
<ol>
<li><p>任何可以传给<code>iter</code>而没有引发<code>TypeError</code>的对象都是可迭代对象。</p>
</li>
<li><p>任何可以传给<code>next</code>而没有引发<code>TypeError</code>的对象都是迭代器。</p>
</li>
<li><p>任何在传给<code>iter</code>时返回自身的对象都是迭代器。</p>
</li>
</ol>
<p>这是Python中的迭代器协议。</p>
<p>迭代器还能创建包含无限多个元素的对象，关于这方面的内容请参阅《Python大学实用教程》中的有关内容。</p>
<h2 id="迭代器无处不在"><a href="#迭代器无处不在" class="headerlink" title="迭代器无处不在"></a>迭代器无处不在</h2><p>Python中的迭代器很多，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = enumerate(letters) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e </span><br><span class="line">&lt;enumerate object at <span class="number">0x7f112b0e6510</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(e) </span><br><span class="line">(<span class="number">0</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p>在Python3中，<code>zip</code>、<code>map</code>和<code>filter</code>对象也是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = zip(numbers, letters) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z </span><br><span class="line">&lt;zip object at <span class="number">0x7f112cc6ce48</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(z) </span><br><span class="line">(<span class="number">1</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p>Python中的文件对象也是迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(open(<span class="string">'hello.txt'</span>)) </span><br><span class="line"><span class="string">'hello world\n'</span></span><br></pre></td></tr></table></figure>

<p>在Python、标准库和第三方Python库中还有许多内置的迭代器。</p>
<p>至此，本文开始时所提到的那三个坑，已经可以给出完美的解释了。</p>
<p>最后，要强调，这里所介绍的有关迭代器概念，只是对《Python大学实用教程》中没有特别强调或者容易忽视的地方给予补充和强调，在这本书中，对循环、迭代和迭代器、生成器有比较全面的介绍，请参阅。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]. <a href="https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python/#Generators_are_iterators" target="_blank" rel="noopener">https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python/#Generators_are_iterators</a></p>
<p>​        </p>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/03/10/remove-column-from-dataframe/">
        <span class="nav-arrow">← </span>
        
          从DataFrame中删除列
        
      </a>
    
    
      <a class="nav-right" href="/2021/03/24/unit-tests-part-1/">
        
          How to Write Unit Tests in Python
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <!--% if (theme.qrcode) { %-->
      <div class="qrcode">
        <!--canvas id="share-qrcode"></!--canvas-->
        <img src="https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg" width=400>
        <p class="notice">关注微信公众号，读文章、听课程，提升技能</p>
      </div>
    <!--% } %-->
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#踩过的坑"><span class="toc-nav-text">踩过的坑</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1、第二次无果"><span class="toc-nav-text">1、第二次无果</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2、检查无效"><span class="toc-nav-text">2、检查无效</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3、解包"><span class="toc-nav-text">3、解包</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#复习for循环"><span class="toc-nav-text">复习for循环</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#可迭代对象和序列"><span class="toc-nav-text">可迭代对象和序列</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Python的for循环"><span class="toc-nav-text">Python的for循环</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#迭代器"><span class="toc-nav-text">迭代器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#不用for的循环"><span class="toc-nav-text">不用for的循环</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#生成器是迭代器"><span class="toc-nav-text">生成器是迭代器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#迭代器无处不在"><span class="toc-nav-text">迭代器无处不在</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#参考文献"><span class="toc-nav-text">参考文献</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://qiwsir.github.io/2021/03/16/loop-better/';
    var banner = ''
    /*if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }*/
    //$('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by 老齐教室 | <a href='http://www.beian.miit.gov.cn' target="_blank" rel="noopener">苏ICP备13034293号-2 </a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>